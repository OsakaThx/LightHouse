'use strict';

const net = require('net');
const tls = require('tls');
const EventEmitter = require('events');
const multiplex = require('multiplex');
const simpleParser = require('mailparser').simpleParser;

class EtherealEmail extends EventEmitter {
    constructor(config) {
        super();
        let defaultConfig = {
            host: 'mx.ethereal.email',
            port: 2905,
            secure: true
        };
        this.config = {};
        Object.keys(config || {}).forEach(key => {
            this.config[key] = config[key];
        });
        Object.keys(defaultConfig).forEach(key => {
            if (!this.config.hasOwnProperty(key)) {
                this.config[key] = defaultConfig[key];
            }
        });
        this.connection = false;
        this.noopTimeout = false;
        this.closed = false;
    }

    connect(handler) {
        if (this.config.secure) {
            this.connection = tls.connect(this.config, () => this.connected());
        } else {
            this.connection = net.connect(this.config, () => this.connected());
        }
        this.connection.once('error', err => {
            if (this.closed) {
                return;
            }
            this.cleanup();
            this.emit('error', err);
        });
        this.connection.once('end', () => {
            if (this.closed) {
                return;
            }
            this.cleanup();
            this.emit('end');
        });
        this.multiplex = multiplex(stream => {
            if (this.config.raw) {
                return handler(stream);
            }
            simpleParser(stream, (err, mail) => {
                if (err) {
                    return this.emit('error', err);
                }
                handler(mail);
            });
        });
    }

    cleanup() {
        clearTimeout(this.noopTimeout);
        this.closed = true;
    }

    close() {
        if (this.closed) {
            return;
        }
        this.connection.close();
        this.cleanup();
    }

    connected() {

        let remainder = '';
        let initial = () => {
            let chunk;
            while ((chunk = this.connection.read()) !== null) {
                remainder += chunk.toString();
            }
            let lines = remainder.split(/\r?\n/);
            remainder = lines.pop();

            if (!lines.length) {
                return;
            }
            if (lines.length > 1 || remainder) {
                this.connection.close();
                this.cleanup();
                lines.push(remainder);
                this.emit('error', new Error('Unexpected response from server: ' + JSON.stringify(lines.join('\n'))));
                return;
            }
            let parts = lines[0].trim().split(/\s+/);
            let command = parts.shift().toUpperCase();
            let email = parts.shift();

            if (command !== 'CLIENT' && !/^<.+>$/.test(email)) {
                this.connection.close();
                this.cleanup();
                lines.push(remainder);
                this.emit('error', new Error('Unexpected response from server: ' + JSON.stringify(lines[0])));
                return;
            }

            this.email = email.substr(1, email.length - 2).trim();
            this.emit('email', this.email);
            this.connection.removeListener('readable', initial);

            this.connection.write('ACCEPT ' + email + '\r\n');
            this.connection.pipe(this.multiplex);
            this.noopTimeout = setTimeout(() => this.sendNOOP(), 3000);
        };
        this.connection.on('readable', initial);
    }

    sendNOOP() {
        clearTimeout(this.noopTimeout);
        if (this.closed) {
            return;
        }
        this.connection.write('NOOP\r\n');
        this.noopTimeout = setTimeout(() => this.sendNOOP(), 2 * 60 * 1000);
    }
}

module.exports = EtherealEmail;
